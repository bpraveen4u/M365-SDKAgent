using Azure.AI.Agents.Persistent;
using Azure.Identity;
using ElAgentApi.Bot.Models;
using ElAgentApi.Bot.Plugins;
using Microsoft.Agents.Builder;
using Microsoft.Agents.Core.Models;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.AzureAI;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.ChatCompletion;
using System.Configuration;
using System.Text;
using System.Threading;


namespace ElAgentApi.Bot.Agents
{
    public class OfferingsAgent
    {
#pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
        AzureAIAgent aiAgent;

        private PersistentAgentsClient agentsClient;

        public OfferingsAgent(IConfiguration configuration)
        {
            agentsClient = AzureAIAgent.CreateAgentsClient(configuration.GetValue<string>("AIProjectConnectionString")!, new DefaultAzureCredential());
            var agent = agentsClient.Administration.GetAgent("asst_YK2flcJLkjtQBgnEC9qkJsiN");
            aiAgent = new(agent, agentsClient);
        }

        public async Task InvokeAgentAsync(string input, ITurnContext turnContext, ChatHistory chatHistory, CancellationToken cancellationToken)
        {
            AzureAIAgentThread agentThread = new(aiAgent.Client);

            var fileReferences = new List<FileReference>();
            var citations = new List<Citation>();
            var quote = string.Empty;

            ChatMessageContent message = new(AuthorRole.User, input);
            try
            {
                await foreach (StreamingChatMessageContent chunk in aiAgent.InvokeStreamingAsync(message, agentThread, cancellationToken: cancellationToken))
                {
                    // get the annotation content from the message chunk items, if there are any
                    var annotations = chunk.Items.OfType<StreamingAnnotationContent>();

                    foreach (StreamingAnnotationContent annotation in annotations)
                    {
                        // check if the file reference already exists in the list and skip it if it does
                        if (fileReferences.Any(fr => fr.Quote == annotation.Label)) { continue; }

                        var agentFile = await aiAgent.Client.Files.GetFileAsync(annotation.ReferenceId, cancellationToken);
                        var citation = new Citation(string.Empty, agentFile.Value.Filename, "https://m365.cloud.microsoft/chat");

                        var fileReference = new FileReference(agentFile.Value.Id, agentFile.Value.Filename, annotation.Label, citation);
                        fileReferences.Add(fileReference);
                    }

                    // if the message chunk content is empty, we can skip it
                    // this happens when the chunk contains StreamingAnnotationContent items
                    if (chunk.Content == null) { continue; }

                    // if the previous message chunk contained the citation quote, we can process it now
                    if (quote != string.Empty)
                    {
                        var fileReferenceIndex = fileReferences.FindIndex(fr => fr.Quote == quote);
                        //turnContext.StreamingResponse.QueueTextChunk($" [{fileReferenceIndex + 1}] ");

                        // reset the quote to empty string to avoid processing it again
                        quote = string.Empty;
                        continue;
                    }

                    // if the message chunk contains an annotation quote 【4:0†source】
                    // store the value for the next message chunk so we can process it
                    // we don't want to send it to the user yet
                    if (chunk.Content.Contains('【'))
                    {
                        quote = chunk.Content;
                        continue;
                    }
                    else
                    {
                        // just a regular message chunk, we can send it to the user
                        turnContext.StreamingResponse.QueueTextChunk(chunk.Content);
                    }

                    //chatHistory.Add(chunk.Content);
                    //yield return response;
                }

                // enable generated by AI label
                //turnContext.StreamingResponse.EnableGeneratedByAILabel = true;

                // add sensitivity label
                //turnContext.StreamingResponse.SensitivityLabel = new SensitivityUsageInfo()
                //{
                //    Name = "General",
                //    Description = "Business data which is NOT meant for public consumption. This can be shared with internal employees, business guests and external partners as needed."
                //};

                // add citations
                foreach (var fileReference in fileReferences)
                {
                    citations.Add(fileReference.Citation);
                }
                //turnContext.StreamingResponse.AddCitations(citations);

            }
            finally
            {
                await turnContext.StreamingResponse.EndStreamAsync(cancellationToken);
            }

        }
    }
}
